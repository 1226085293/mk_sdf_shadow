// Copyright (c) 2017-2020 Xiamen Yaji Software Co., Ltd.
CCEffect %{
  techniques:
  - passes:
    - vert: sprite-vs:vert
      frag: sprite-fs:frag
      depthStencilState:
        depthTest: false
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha
      rasterizerState:
        cullMode: none
      properties:
        alphaThreshold: { value: 0.5 }
        light_pos_v4s: { value: [0.0, 0.0, 0.0, 0.0] }
        light_radius_v4s: { value: [0.0, 0.0, 0.0, 0.0] }
        light_color_v4s: { value: [0.0, 0.0, 0.0, 0.0] }
        light_polygon_v4s: { value: [0.0, 0.0, 0.0, 0.0] }
}%

CCProgram sprite-vs %{
  precision highp float;
  #include <cc-global>
  #if USE_LOCAL
    #include <cc-local>
  #endif
  #if SAMPLE_FROM_RT
    #include <common>
  #endif
  in vec3 a_position;
  in vec2 a_texCoord;
  in vec4 a_color;

  out vec4 color;
  out vec2 uv0;

  vec4 vert () {
    vec4 pos = vec4(a_position, 1);

    #if USE_LOCAL
      pos = cc_matWorld * pos;
    #endif

    #if USE_PIXEL_ALIG4ME4T
      pos = cc_matView * pos;
      pos.xyz = floor(pos.xyz);
      pos = cc_matProj * pos;
    #else
      pos = cc_matViewProj * pos;
    #endif

    uv0 = a_texCoord;
    #if SAMPLE_FROM_RT
      CC_HA4DLE_RT_SAMPLE_FLIP(uv0);
    #endif
    color = a_color;

    return pos;
  }
}%

CCProgram sprite-fs %{
  precision highp float;
  #include <embedded-alpha>
  #include <alpha-test>
  #include <cc-global>

  #include <mk_light>
  #include <mk_dist_field_func>
  #include <mk_dist_field_transform>
  
  // 光最大数量
  #define max_light_length 10
  // 阴影最大步进，影响阴影生成距离，光源范围过大导致阴影部分消失可增大此常量
  #define max_shadow_step 64
  // 所有多边形坐标数量
  #define all_polygon_pos_size 384
  


  in vec4 color;

  uniform ConstantsVec {
    // 光坐标数组
    vec4 light_pos_v4s[max_light_length];
    // 光半径数组
    vec4 light_radius_v4s[max_light_length];
    // 光颜色数组
    vec4 light_color_v4s[max_light_length];
    // 多边形数组
    vec4 light_polygon_v4s[all_polygon_pos_size];
  };

  #if USE_TEXTURE
    in vec2 uv0;
    #pragma builtin(local)
    layout(set = 2, binding = 10) uniform sampler2D cc_spriteTexture;
  #endif

// 多边形
// float sdf_polygon(in vec2 render_v2)
// {
//   vec2 temp_v2 = vec2(light_polygon_v4s[0].x, light_polygon_v4s[0].y);
//   vec2 temp2_v2 = vec2(0);
//   float d = dot(render_v2 - temp_v2, render_v2 - temp_v2);
//   float s = 1.0;
//   int j = 4 - 1;
//   for(int i = 0; i < 4; i++ )
//   {
//     temp_v2 = vec2(light_polygon_v4s[i].x, light_polygon_v4s[i].y);
//     temp2_v2 = vec2(light_polygon_v4s[j].x, light_polygon_v4s[j].y);
//     vec2 e = temp2_v2 - temp_v2;
//     vec2 w = render_v2 - temp_v2;
//     vec2 b = w - e*clamp(dot(w, e) / dot(e, e), 0.0, 1.0 );
//     d = min(d, dot(b, b));
//     bvec3 c = bvec3(render_v2.y >= light_polygon_v4s[i].y, render_v2.y < light_polygon_v4s[j].y, e.x * w.y > e.y * w.x);
//     if(all(c) || all(not(c))) {
//       s*=-1.0;
//     }  
//     j = i;
//   }
//   return s*sqrt(d);
// }

  // 距离场函数
  float scene_dist(vec2 render_v2) {
	  float dist = sdf_circle(translate(render_v2, vec2(200.0, 250.0)), 50.0);
    return dist;
    // float dist2 = sdf_polygon(render_v2);
    // return merge(dist, dist2);
  }

  // 阴影
  float shadow(vec2 render_v2, vec2 light_v2, float hard_f) {
    // 当前渲染位置到光源位置的方向向量
    vec2 render_to_light_dir_v2 = normalize(light_v2 - render_v2);
    // 渲染位置至光源位置距离
    float render_to_light_dist_f = length(render_v2 - light_v2);
    // 可见光的一部分，从一个半径开始（最后添加下半部分）；
    float brightness_f = hard_f * render_to_light_dist_f;
    // 行走距离
    float travel_dist_f = 0.01;

    for (int k_i = 0; k_i < max_shadow_step; ++k_i) {				
      // 当前位置到场景的距离
      float dist_f = scene_dist(render_v2 + render_to_light_dir_v2 * travel_dist_f);

      // 渲染点在物体内部
      if (dist_f < -hard_f) {
          return 0.0;
      }
          
      // dist_f 不变，brightness_f 越小，在越靠近光源和物体时 brightness_f 越小
      brightness_f = min(brightness_f, dist_f / travel_dist_f);
      
      // max 避免渲染点距离物理表面过近导致极小耗尽遍历次数，所以有可能会跳过物体距离小于1.0的阴影绘制
      // abs 避免朝回走
      travel_dist_f += max(1.0, abs(dist_f));

		  // 渲染点的距离超过光源点
      if (travel_dist_f > render_to_light_dist_f) {
        break;
      }
    }

	  // 消除波纹线
	  // brightness_f * render_to_light_dist_f 根据距离平滑, 离光源越近越小
    // brightness_f = clamp((brightness_f * render_to_light_dist_f / hard_f), 0.0, 1.0);
    // 放大阴影，hard_f 越大结果越小则阴影越大, hard_f / (2.0 * hard_f) 使结果趋近于0.5，用于平滑过渡
    brightness_f = clamp((brightness_f * render_to_light_dist_f + hard_f) / (2.0 * hard_f), 0.0, 1.0);
    brightness_f = smoothstep(0.0, 1.0, brightness_f);
    return brightness_f;
  }

  vec4 frag () {
    vec4 output_v4 = vec4(0.2, 0.2, 0.2, 1.0);
    // 渲染坐标
    vec2 render_v2 = gl_FragCoord.xy + vec2(0.5);
    // 屏幕中心坐标
    vec2 center_v2 = cc_screenSize.xy / 2.0;
    
    float dist_f = scene_dist(render_v2);


    // 绘制光
    for (int k = 0; k < max_light_length; k++) {
      // 无法知道数组长度，所以最后位 x 传 -1
      if (light_pos_v4s[k].x == -1.0) {
        break;
      }
      vec4 light_v4 = draw_light(render_v2, light_pos_v4s[k].xy, light_radius_v4s[k].x, light_color_v4s[k]);
      float shadow_f = shadow(render_v2, light_pos_v4s[k].xy, 10.0);
      output_v4 += light_v4 * shadow_f;
    }

    // 圆
    output_v4 = mix(output_v4, vec4(1.0, 0.4, 0.0, 1.0), clamp(-dist_f, 0.0, 1.0));

    // output_v4 *= color;
    // ALPHA_TEST(output_v4);
    return output_v4;
  }
}%
